
// 23-3 --------true-false.js

// 0     --falsy
// ""    --falsy
// undefined    --falsy
// null    --falsy
// NaN    --falsy এইখানে যেই সংখ্যা গুলা আছে তা থাকলে ফলস হবে
// false    --falsy

// " ", "0", [], {}, true -----truthy  এইগুলা থাকলে বলা যাবে এফ এই চলে যাবে মানে ট্রু 

// const age = 41;  // এখানে 41  এর যায়গায়  কোন মিথ্যা মান থাকলে তা মিথ্যে মানে ইলসে চলে যাবে
// if(age){
//     console.log("condition is true");
// }
// else{
//     console.log("condition is false");
// }


// const name = "Rahim";
// if(name){
//     console.log("condition is true");
// }
// else{
//     console.log("condition is false");
// }


//let name;
let name = {};
// console.log(name);
if(name){
    console.log("condition is true");
}
else{
    console.log("condition is false");
}









// 23-3 ---null-vs-undefined
// let pakhi;       // যদি এইভাবে রাখি তাহলে আনডিফান্ট হবে। মানে এখানে যেহেতু কোন মান দেওয়া নাই তাই এইটাকে আনডিফাইন দেখাবে
// console.log(pakhi)  


// function add(num1, num2){
//     console.log(num1 + num2);   // এইটার মান আসবে 
//     return; // যদি ফাংশনের মান কে রিটান্ট না করি তাহলে তা আনডিফাইন্ট দেখাবে। আবার যদি সুধু রিটান্ট লেখি তাহলে কিন্তু কোন মানটা রিটান্ট করবো তা ডিফান্ট না করি তাহলে আনডিফান্ট মান আসবে । 
// }
// const result = add(13, 82); 
// console.log(result); // এ্টার মান আন ডিফান্ট আসবে কারন সেখান থেকে সুধু রিটান্ট লেখা আছে কি রিটান্ট করবে তা লেখা নািই


// function add(num1, num2){
//     console.log(num1, num2);  // 13 undefined
// }
// const result = add(13);
// console.log(result);  // undefined


// const premik = {name: "Hassan", phone: 25464156};
// console.log(premik.gf); // যেহেতু অবজেক্ট  এ gf এর বেলু দেওয়া নাই তাই আনডিফাইন্ট হবে 


// let fun = undefined;
// console.log(fun);     //  undefined

// নাল মানে হলো কোন কিছু নাই বা নন এজিস্ট বোঝায়। কিন্তু আনডিফাইন্ট হলো অনেক রকম করে আমরা বের করতে পারি। যেমন কোন একটা বেরিয়েবল না ডিকলার করা , কোন একটা অবজেক্ট না ডিকলার করে কনশল করলেও হবেনা। অনেক ভাবেই করা যায় কোন বেলু না্ এড করে তাকে কনশল করলেই ্আমরা সাধারনত আনডিফান্ট পেতে পারি।










// 23.4 double-vs-triple-equal.js // ডাবল ইকোয়েল মানে হলো সুধু বেলুটাকে চেক করবে আর যদি ট্রিপল ইকোয়েল থাকে তাহলে বেলু সহ টাইপ দেখাবে।  ডাবল (==) যদি দেই তাহলে 2==”2” সত্যি বলবে । কিন্তু যদি 2===“2” লেখি তাহলে মিথ্যা বলবে। == দিলে সুধু বেলু দেখবে কোন টাইপের তা দেখবেনা আর === দিলে প্রথম যদি নাম্বার দেই তাহলে 2টাও নাম্বার ই হতে হবে। অন্য কিছু হলে হবেনা। যদি আমি প্রথমটার মান 1 বা 0 দেই আর দিতীয় টার মান ট্রু  বা ফল্স দেই তাহলে আর == মাজে দেই তাহলে ট্রু==1 আর ফল্স ==0 এই দুইটা ট্রু হবে অন্য কোন মান এই রকম হবেনা। কিন্তু === দিলে বেলু সহ চেক করবে।
const first = 2;
const second = "2";
if(first === second){
    console.log("condition is true");
}
else{
    console.log("condition is false");
}








// 23.5 ----map-filter
// const numbers = [3, 4, 5, 6, 7, 8];
// const output = [];
// for (let i = 0; i < numbers.length; i++) {
//     const element = numbers[i];
//     const result = element * element;
//     output.push(result);
// }
// console.log(output);  // এইটাতে আউট পুট আসবে সবগুলার স্কুয়ার


// function square (element){
//     return element * element;
// }
// const square = element => element * element;
// const square = x => x * x;  এই তিনটা যাস্ট এক্সামপল কারন এই তিনটা সবগুলা একই রকম হবে


// const numbers = [3, 4, 5, 6, 7, 8];
// numbers.map(function(element, index, array ){       //map      // এখানে element মানে সুধু সংখ্যা গুলা দেখাবে । ইনডেক্স মানে হলো সংখ্যার পজিশন 0 , 1, 2 এই রকম টাইপের দেখাবে্ । আর এরে মানে হলো পুরা সংখ্যা টাকে এরের মত দেখাবে ্ [3, 4, 5, 6] েএই এরের মত
//     console.log(element, index, array);   
// })


// const numbers = [3, 4, 5, 6, 7, 8];
// const result = numbers.map(function(element){
//     return element * element;
// })
// console.log(result);   //map  // এই সংখ্যা গুলাকে স্কুয়ায় করা হবে 


// const numbers = [3, 4, 5, 6, 7, 8];
// const result = numbers.map(x => x * x);     //map   // আগের মত সেইম হবে স্কুয়ার এর মান । এটা সটকাট
// console.log(result);


// const numbers = [3, 4, 5, 6, 7, 8];
// const bigger = numbers.filter(x => x >5);    //filter    // এটার মানে হলো 5 থেকে বড় সংখ্যা গুলাকে দেখাবে এরের মত  
// console.log(bigger);


const numbers = [3, 4, 5, 6, 7, 8];
const bigger = numbers.find(x => x >5);    // find    // এইটা হলো 5 থেকে বড় সুধু প্রথম সংখ্যাটাকেই কনশল করা হবে।
console.log(bigger);










// 23.6    object-proparty.js
const students = [
    {id: 21, name: 'Omar Sunny'},
    {id: 31, name: 'Maannaa'},
    {id: 41, name: 'Moyori'},
    {id: 71, name: 'Deepjol'}
];
// // for (let i = 0; i < students.length; i++) {
// //     const element = students[i];
// //     studentsName = element.name;
// //     console.log(studentsName)
// // }    // এইভাবে আমি ট্রাই করছি  এইভাবে করলে সবগুলা চলে আসবে কোন এরের মত আসবেনা। কিন্তু নিচের নিয়ম টা হলো মেইন।

// const names = students.map(s => s.name);  // map  // এখানে মেপ করা হইছে । এবং এস এর যায়গায় আমি এ বি এক্স ওয়াই সব কিছু বা ইলিমেন্ট ও ব্যবহার করতে পারি।  [ 'Omar Sunny', 'Maannaa', 'Moyori', 'Deepjol' ]
// console.log(names);  // এই ভাবে করলে আমরা পাবো এরের মধ্যে স্টিং আকারে দাবে।

// const ids = students.map(s => s.id);    // map  // এই রকম করলে স্টুডেন্টচ এর বিতরে যতগুলা আইডি আছে তা একটা এরের মধ্যে দেখাবে [ 21, 31, 41, 71 ]
// console.log(ids);

// const bigger = students.filter(s => s.id>40);      //filter   // 40 এর উপরে যেই আইডির মান গুলা আছে  সেই আইডির সকল বেল দেখা যাবে [ { id: 41, name: 'Moyori' }, { id: 71, name: 'Deepjol' } ]
// console.log(bigger);

const biggerOne = students.find(s => s.id>40);      //find   // 40 এর উপরে যেই আইডির মান  আছে সুধু একটা মান নিবে । সেই আইডির সকল বেল দেখা যাবে { id: 41, name: 'Moyori' }
console.log(biggerOne);








//23.7 --- scope.js   
// হুস্টিং হলো কোন একটা রেরিয়েবল উপরের দিকে নিয়ে যাওয়াকেই বলা হয় । িযদি কোন একটা বার আমি ডিকলার করি কিন্তু এর আগেই যদি আমি কনশল ডিকলার করি তাহলে তা আনডিফান্ট দিবে । িএর মানে বার এর বেলু টা উপরে যায়না বেরিয়েবল টাই সুধু উপরে যায়। কিন্তু কনস্ট বা লেট যদি আমি ব্যবহার করি তাহলে  আগে কিছুই পাওয়া যাবেনা।
let bonus = 20;
function sum(first, second){
    let result = first + second + bonus;
    // console.log(bonus);    // বিতর থেকে বাইরে বেরিয়েবল কনসল করা যাবে । কিন্ত বাহির থেকে বিতরের গুলাকে কল করা যাবেনা। বাইরে যে বেরিয়েবল গুলা থাকে তাদের যে কোন জায়গাথেকে  কল করা যায় কিন্তু বিতরে যেগুলা থাকে তা সবগুলা বিতরের কনশল করতে হবে।ে
    if(result > 9){
        let mood = 'happy';
        mood = 'lovely';
        mood = 'upSad'
        console.log(mood);  // বিতর থেকে বাইরে বেরিয়েবল কনসল করা যাবে । কিন্ত বাহির থেকে বিতরের গুলাকে কল করা যাবেনা। বাইরে যে বেরিয়েবল গুলা থাকে তাদের যে কোন জায়গাথেকে  কল করা যায় কিন্তু বিতরে যেগুলা থাকে তা সবগুলা বিতরের কনশল করতে হবে।ে
    }
    return result;
}
// কনস্ট বা লেট হলো বল্ক এটা { } এই টার বিতরেই সুধু থাকবে । আবার যদি কখনো কনশল আগে করি তাহলে এরোর দেখাবে কিন্তু বার যেকোন যায়গাথেকে্ে িকল করা হোক না কেনো সব সময়ই পাওয়া যাবে। যদি আগে কনশল করা হয় তাহলে আনডিফাইন্ট হবে।
const output = sum(3, 7);
console.log(output);








//23.7 --- closure.js  
// একটা ফাংশনের বিতরে যদি আরেকটা ফাংশন থাকে তাহলে তা একটা ক্লোজ এনবারমেন্ট তৈরি করে।  বিতরের যে ফাংশন টা রিটান্ট করতেচে বা কল করেছেঃ। সে যদি তার বাইরের কোন বেরিয়েবল কে িএকচেন্স করে তাহলে সে েএকটা মান রেখে দেয় এবং এই একই বেরিয়েবল বার বার ডিকলার করা হলে এক এক করে বারতে থঅকবে। আগ েপরে করা যাবে কোন সমস্যা নাই।         
function stopWatch(){
    let count = 0;
    return function(){
        count++;
        return count;
    }
}
const clock1 = stopWatch();
console.log(clock1());      //1  // 1, 1 করে বারতে থাকবে। কারন উপরে কাউন্ট করা হেইছে
console.log(clock1());      //2
console.log(clock1());      //3
console.log(clock1());      //4

const clock2 = stopWatch();
console.log(clock2());      //1
console.log(clock2());      //2
console.log(clock1());      //5    // এইটা যেহেতু প্রথমটাই আবার ডিকলার করা হইছে তাই 5 হবে
console.log(clock2());      //3








// 23.9 --- array-spilt.js
// const nums = [5, 9, 8, 7, 71, 76, 74, 87];
// const part = nums.slice(2, 5);     //slice     // 2 থেকে শুরু হবে আর 5 এর আগ পর্যন্ত চলতে থাকবে। যেই এরি টা প্রথমে থাকবে তা থেকে শুরুহবে এবং এর পরের যে এরের নাম্বার টা থাকবে তার আগের মান টা পর্যন্ত আসবে কিছুটা >5 েএই রকম মানে 5 লেখলে 4 পর্যন্ত চলবে।
// console.log(part);
// console.log(nums);   // এখানের নাম্বার গুলা slice করলে কোন পরিবর্তন হবেনা।



// const nums = [5, 9, 8, 7, 71, 76, 74, 87];
// const removed = nums.splice(2,5);  // splice  // এরের 2 নাম্বার থেকে শুরু হলে 5টা মান কে রাখবে। এখানে যদি প্রথমে 2 দেই এবং পরে 1 দদেই তাহলেও এইখান 2 নাম্বার এরে থেকে শুরু করে শুধু েএকটা নাম্বার নিবে।
// console.log(removed);
// console.log(nums)    // এখানের নাম্বার গুলা splice করলে কোন পরিবর্তন হবে উপরের যেই নাম্বার গুলাকে আমি রিমুভ করবো সেই নাম্বার গুলা রিমুভ হয়ে যাবে।         

// nums = [5, 9, 8, 7, 71, 76, 74, 87];
// const removed = nums.splice(2,5, 1111, 2222, 333);  // splice  // এরের 2 নাম্বার থেকে শুরু হলে 5টা মান কে রাখবে। এখানে যদি প্রথমে 2 দেই এবং পরে 1 দদেই তাহলেও এইখান 2 নাম্বার এরে থেকে শুরু করে শুধু েএকটা নাম্বার নিবে  । আবার প্রথম দুইটা সংখ্যা মানে হলো--- 1ম টা হলো এইটা থেকে শুরু করেবে। 2য় টা হলো এইটা যত লেখা আছে ততটা পর্যন্ত মান নিবে। 3য়-থেকে যত গুলাই লেখি ততগুলা সংখ্যা এই রিমুভ করা যায়গায় মেইন ফাংশনে বসবে। কিন্তু রিমুভ সুধু হবে প্রথম সংখ্যা 2য় সংখ্যা গুলাই।         
// console.log(removed);
// console.log(nums)    // এখানের নাম্বার গুলা splice করলে কোন পরিবর্তন হবে উপরের যেই নাম্বার গুলাকে আমি রিমুভ করবো সেই নাম্বার গুলা রিমুভ হয়ে যাবে।   এইখানে splice করা সংখ্যা গুলার পরের পার্টের সংখ্যা গুলা রিমুভকরা যায়গায় বসবে।



nums = [5, 9, 8, 7, 71, 76, 74, 87];
const together = nums.join("");      // join  //(", ") এইখানে লেখলে সবগুলা সংখ্যার পরে পরে একটা করে কমা চলে আসবে এবং কোনো এরের মধ্যে দেখাবেনা। আবার যদি (" এখানে যা লেখি তাই আসবে ")   মানে দুই টা সংখ্যার মাজে  
console.log(together);









//23.10 break-continue.js
const nums = [1, 2, 2, 1, 3, 4, 2, 1, 7, 8, 9]
for (let i = 0; i < nums.length; i++) {
    if(nums[i]>3){   //  (nums[i]>3)  মানে আই এর কোন সংখ্যা যদি 3 এর সমান বা বড় হয় তাহলে সেখানেই ব্রেক করে ফেলবে  পরে যদি 3 এর সমান বা ছোট সংখ্যা থাকেও তাও সে সেখানে যেতে পারবেনা। সে প্রথম যেই 3 িএর বড় সংখ্যা  পাবে তখন থেকিই সে েব্রেক করে ফেলবে।  এখানে 3 এর পরি বর্তে যেকোন মান লেখা যাবে এবং এই মান গুলা হবে কিছুটা বিপরিত মুখি েএবং 3এর সমান থেকে। যদি না বুঝি তাহলে কনশল করে দেখলে কি্লায়ার হয়ে যাবো।
        break;
    }
    console.log(nums[i]);
}


// const nums = [1, 0, -2, 33, 4, -5, -6, 7, -8, 9]
// for (let i = 0; i < nums.length; i++) {
//     if(nums[i]<0){  // এখানে আই এর বেলু যদি  0 এ্রর বড় হয় তাহলে সেই সকল মান গুলা কনশল হবে। এইটা কিছু্টা উলটা সিস্টেম nums[i]<0   এইখানে 0 বা যে কোন সংখ্যা ‍যদি আমি ডিকলার করি তাহলে যেই সংখ্যা ডিকলার করা হইছে সেই সংখ্যা থেকে েশুরু করে এর উপরে যেই সংখ্যা গুলা পবে তাকে সিরিয়াল মত দেখািইতে থাকবে। ্ আবার যদি nums[i]>0 করি তাহলে আগের শর্ত মত 0 থেকে শুরু করে এর যত ছোট সংখ্যা গুলা আছে সিরিয়াল অনুযায়ী দেখাবে।     
//         continue;
//     }
//     console.log(nums[i]);
// }









